---
sidebar_position: 2
---

# Why AtomJS?

AtomJS was built from the idea that **UI frameworks should be powerful, but also clear and predictable**.

Modern frameworks like React and Vue dominate front-end development, but both come with tradeoffs:

-   **React** gives developers flexibility, but has grown increasingly complex with hooks, context, and meta-layers that can feel abstract and confusing.
-   **Vue** makes things approachable, but often hides important details behind reactive magic, which can make debugging or scaling harder.

AtomJS takes a different path:

---

## The Philosophy of AtomJS

-   **Class-based components** — AtomJS embraces a class-driven API, where components are explicit, self-contained, and easy to extend.
-   **Explicit over implicit** — no hidden reactivity layers or magical behaviors. What you write is what runs.
-   **Lightweight core** — a virtual DOM, JSX runtime, and DOM rendering utilities without unnecessary extras.
-   **TypeScript first** — built with TypeScript from the ground up for strong typing and great developer experience.
-   **Simplicity** — designed so you can read the source, understand it, and build confidently.

---

## Who is AtomJS for?

-   **React developers** who want a simpler, more class-oriented API.
-   **Vue developers** who appreciate simplicity but want more control and transparency.
-   **Framework explorers** who enjoy understanding how things work under the hood.
-   **Teams** that value TypeScript, predictability, and long-term maintainability.

---

## The Road Ahead

AtomJS is still young — but growing fast.  
Right now, the focus is on the **core runtime**: rendering, JSX support, and component basics.

Next, the project will expand into:

-   State management patterns
-   Routing solutions
-   Developer tooling and devtools integration
-   Ecosystem libraries

---

:::tip
If you’re ready to dive in, head to the [Quickstart guide](./intro.md) and run AtomJS in your first project.
:::
